<!DOCTYPE html>
<html>
<head>
    <title>WebXR MR Measure App</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body { margin: 0; font-family: Arial, sans-serif; color: white; background-color: #111; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        #arButton { padding: 12px 20px; font-size: 18px; background-color: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; }
        #arButton:disabled { background-color: #555; }
        #measureInfo { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); padding: 10px; background-color: rgba(0,0,0,0.7); border-radius: 5px; font-size: 16px; text-align: center; z-index: 100; display: none; }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>
    <h1>MR Measuring Tool</h1>
    <button id="arButton">Start AR Measuring</button>
    <div id="measureInfo">Point and click controller trigger to place markers.</div>

    <script>
        let xrSession = null;
        let xrReferenceSpace = null;
        let gl = null;
        let renderer = null;
        let scene = null;
        let camera = null;
        let hitTestSource = null;
        let reticle = null; // A visual guide for where you're pointing

        const arButton = document.getElementById('arButton');
        const measureInfo = document.getElementById('measureInfo');
        let points = [];
        let line = null;

        async function initXR() {
            if (navigator.xr) {
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (!supported) {
                        arButton.textContent = "AR Not Supported";
                        arButton.disabled = true;
                        return;
                    }
                } catch (e) {
                    console.error("Error checking AR support:", e);
                    arButton.textContent = "AR Error";
                    arButton.disabled = true;
                    return;
                }

                arButton.addEventListener('click', onARButtonClicked);
            } else {
                arButton.textContent = "WebXR Not Available";
                arButton.disabled = true;
            }
        }

        async function onARButtonClicked() {
            if (!xrSession) {
                try {
                    // Request features needed for AR and hit-testing
                    xrSession = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test', 'local-floor', 'dom-overlay'],
                        domOverlay: { root: document.body } // To show HTML elements
                    });
                    xrSession.addEventListener('end', onSessionEnded);

                    // Setup Three.js scene for AR
                    const canvas = document.createElement('canvas');
                    gl = canvas.getContext('webgl', { xrCompatible: true });

                    renderer = new THREE.WebGLRenderer({
                        alpha: true,
                        preserveDrawingBuffer: true,
                        canvas: canvas,
                        context: gl
                    });
                    renderer.autoClear = false;

                    scene = new THREE.Scene();
                    camera = new THREE.PerspectiveCamera(); // Will be updated by WebXR

                    // Create a reticle (a small ring to show where you are pointing)
                    const reticleGeometry = new THREE.RingGeometry(0.03, 0.04, 32); // Inner, outer radius, segments
                    const reticleMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
                    reticle = new THREE.Mesh(reticleGeometry, reticleMaterial);
                    reticle.visible = false; // Initially hidden
                    scene.add(reticle);

                    await renderer.xr.setSession(xrSession);
                    xrReferenceSpace = await xrSession.requestReferenceSpace('local-floor');
                    
                    // Setup hit testing
                    const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                    hitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

                    xrSession.requestAnimationFrame(onXRFrame);
                    
                    arButton.textContent = "Exit AR";
                    measureInfo.style.display = 'block';
                    measureInfo.textContent = "Point and click trigger to place first marker.";

                    // Add controller input listener
                    xrSession.addEventListener('selectstart', onSelectStart); // 'select' is trigger press

                } catch (e) {
                    console.error("Could not start AR session:", e);
                    arButton.textContent = "Failed to Start AR";
                }
            } else {
                xrSession.end();
            }
        }

        function onSelectStart(event) {
            if (reticle.visible) { // Place point only if reticle is visible (i.e., pointing at a surface)
                const pointGeometry = new THREE.SphereGeometry(0.02, 32, 32); // Small sphere for marker
                const pointMaterial = new THREE.MeshBasicMaterial({ color: points.length === 0 ? 0x00ff00 : 0x0000ff }); // Green then Blue
                const marker = new THREE.Mesh(pointGeometry, pointMaterial);
                
                marker.position.copy(reticle.position); // Place marker at reticle position
                scene.add(marker);
                points.push(marker);

                if (points.length === 1) {
                    measureInfo.textContent = "First marker placed. Point and click trigger for second marker.";
                } else if (points.length === 2) {
                    measureInfo.textContent = "Second marker placed. Calculating distance...";
                    calculateAndDisplayDistance();
                    // Optionally clear points for next measurement or allow more
                    // For this example, we'll reset after 2 points for a new measurement.
                    // setTimeout(() => { 
                    //     resetMeasurement();
                    //     measureInfo.textContent = "Point and click trigger to place first marker.";
                    // }, 3000);
                } else if (points.length > 2) { // Reset after 2 points
                    resetMeasurement();
                    // Place the new first point
                    marker.material.color.setHex(0x00ff00);
                    scene.add(marker);
                    points.push(marker);
                     measureInfo.textContent = "First marker placed. Point and click trigger for second marker.";
                }
            }
        }

        function calculateAndDisplayDistance() {
            if (points.length === 2) {
                const distance = points[0].position.distanceTo(points[1].position);
                measureInfo.textContent = `Distance: ${distance.toFixed(3)} meters`;

                // Draw a line between the points
                if (line) scene.remove(line); // Remove old line
                const material = new THREE.LineBasicMaterial({ color: 0xff0000 }); // Red line
                const geometry = new THREE.BufferGeometry().setFromPoints([points[0].position, points[1].position]);
                line = new THREE.Line(geometry, material);
                scene.add(line);
            }
        }
        
        function resetMeasurement() {
            points.forEach(p => scene.remove(p));
            points = [];
            if (line) {
                scene.remove(line);
                line.geometry.dispose();
                line.material.dispose();
                line = null;
            }
            measureInfo.textContent = "Point and click trigger to place first marker.";
        }


        function onXRFrame(time, frame) {
            const session = frame.session;
            session.requestAnimationFrame(onXRFrame);

            const pose = frame.getViewerPose(xrReferenceSpace);
            if (!pose) return;

            // Update camera
            camera.matrix.fromArray(pose.transform.matrix);
            camera.projectionMatrix.fromArray(pose.projectionMatrix);
            camera.updateMatrixWorld(true);

            // Hit Testing for Reticle
            if (hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                if (hitTestResults.length > 0) {
                    const hit = hitTestResults[0];
                    const hitMatrix = new THREE.Matrix4().fromArray(hit.getPose(xrReferenceSpace).transform.matrix);
                    reticle.position.setFromMatrixPosition(hitMatrix);
                    reticle.visible = true;
                } else {
                    reticle.visible = false;
                }
            }
            
            // Make reticle always face the camera/viewer
            if (reticle.visible) {
                reticle.lookAt(camera.position);
            }

            renderer.render(scene, camera);
        }

        function onSessionEnded() {
            arButton.textContent = "Start AR Measuring";
            measureInfo.style.display = 'none';
            hitTestSource = null;
            xrSession = null;
            if (renderer) {
                renderer.xr.setSession(null); // Important to unset
            }
            resetMeasurement(); // Clear points and line from scene
            // Optionally, clean up Three.js resources if you're completely done
            // For this simple demo, resetting points/line is sufficient.
        }

        initXR();
    </script>
</body>
</html>
